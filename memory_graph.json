{
  "file_gui_python_function_LucidMemoryApp__build_ui_5": {
    "id": "file_gui_python_function_LucidMemoryApp__build_ui_5",
    "raw": "    def _build_ui(self):\n        \"\"\"Builds the main UI elements.\"\"\"\n        self._build_config_frame()\n        self._build_main_frames()\n        self._build_control_frame()\n        self.refresh_memory_display()\n",
    "summary": "The method constructs and refreshes a graphical user interface.",
    "key_concepts": [
      "build UI",
      "config frame",
      "main frames",
      "control frame",
      "memory display"
    ],
    "tags": [
      "ui construction",
      "python class method",
      "dynamic ui generation",
      "memory display refresh",
      "control frame building",
      "config frame creation",
      "main frames assembly"
    ],
    "follow_up_questions": [],
    "sequence_index": 4,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__load_memory_graph_3": {
    "id": "file_gui_python_function_LucidMemoryApp__load_memory_graph_3",
    "raw": "    def _load_memory_graph(self):\n        \"\"\"Loads the memory graph from the shared JSON file.\"\"\"\n        graph = MemoryGraph()\n        if os.path.exists(MEMORY_GRAPH_PATH):\n            try:\n                graph.load_from_json(MEMORY_GRAPH_PATH)\n                logging.info(f\"Loaded {len(graph.nodes)} nodes from {MEMORY_GRAPH_PATH}\")\n            except Exception as e: # Keep broad except here for file load robustness\n                logging.warning(f\"Memory Load Warning parsing {MEMORY_GRAPH_PATH}: {e}. Starting empty.\", exc_info=False)\n        else:\n             logging.info(f\"Memory file {MEMORY_GRAPH_PATH} not found. Starting empty.\")\n        return graph\n",
    "summary": "Loads and initializes a memory graph from a shared JSON file, starting with an existing structure or creating it anew if the file is missing.",
    "key_concepts": [
      "Memory Graph",
      "JSON File",
      "Shared Path",
      "Nodes Count",
      "Exception Handling",
      "Logging Info",
      "Empty State Start",
      "Robustness Feature"
    ],
    "tags": [
      "memory_graph",
      "json_loading",
      "os_path_exists",
      "exception_handling",
      "node_count_logging",
      "memory_file_not_found",
      "shared_json_file",
      "memorygraph_class",
      "exc_info_false"
    ],
    "follow_up_questions": [],
    "sequence_index": 2,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__build_main_frames_7": {
    "id": "file_gui_python_function_LucidMemoryApp__build_main_frames_7",
    "raw": "    def _build_main_frames(self):\n        main_frame = tk.Frame(self.root)\n        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        self._build_chat_frame(main_frame)\n        self._build_memory_frame(main_frame)\n",
    "summary": "The function `_build_main_frames` constructs and organizes the primary interface frames for a chat application.",
    "key_concepts": [
      "tk.Frame",
      "fill option",
      "expand flag",
      "padding space",
      "chat frame",
      "memory frame",
      "root window"
    ],
    "tags": [
      "tkinter",
      "tkinter frame",
      "pack method",
      "fill option",
      "expand option",
      "padding",
      "chat frame",
      "memory frame"
    ],
    "follow_up_questions": [],
    "sequence_index": 6,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__load_config_2": {
    "id": "file_gui_python_function_LucidMemoryApp__load_config_2",
    "raw": "    def _load_config(self):\n        \"\"\"Loads configuration from JSON file or returns default.\"\"\"\n        cfg = DEFAULT_CONFIG.copy() # Start with defaults\n        if os.path.exists(CONFIG_PATH):\n            try:\n                with open(CONFIG_PATH, \"r\", encoding=\"utf-8\") as f:\n                    loaded_cfg = json.load(f)\n                # Update defaults with loaded values, keeping defaults for missing keys\n                cfg.update(loaded_cfg)\n                logging.info(f\"Loaded configuration from {CONFIG_PATH}\")\n            except (json.JSONDecodeError, Exception) as e:\n                 logging.error(f\"Config Error parsing {CONFIG_PATH}: {e}. Using defaults.\", exc_info=False)\n                 # Keep the default cfg\n        else:\n            logging.warning(f\"Config file {CONFIG_PATH} not found. Creating default.\")\n            try:\n                os.makedirs(os.path.dirname(CONFIG_PATH), exist_ok=True)\n                with open(CONFIG_PATH, \"w\", encoding=\"utf-8\") as f:\n                    json.dump(cfg, f, indent=2) # Save the default cfg\n            except Exception as e:\n                logging.error(f\"Config Error creating default file: {e}\", exc_info=False)\n        return cfg\n",
    "summary": "The function loads configuration from a JSON file or uses defaults if none exists.",
    "key_concepts": [
      "JSON loading",
      "Configuration defaults",
      "File existence check",
      "Config path",
      "Exception handling",
      "Logging info/warning/error",
      "Default configuration saving",
      "OS directory creation",
      "Encoding UTF-8",
      "Indentation in json.dump"
    ],
    "tags": [
      "config loading",
      "json parsing",
      "exception handling",
      "os.path.exists",
      "config defaults",
      "configuration management",
      "encoding utf-8",
      "logging",
      "try-except block",
      "create directory",
      "save to file",
      "update dictionary",
      "default values",
      "error reporting",
      "file i/o operations",
      "software development",
      "python programming"
    ],
    "follow_up_questions": [],
    "sequence_index": 1,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__build_chat_frame_8": {
    "id": "file_gui_python_function_LucidMemoryApp__build_chat_frame_8",
    "raw": "    def _build_chat_frame(self, parent):\n        frame = tk.LabelFrame(parent, text=\"Chat\")\n        frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))\n        self.chat_display = scrolledtext.ScrolledText(frame, wrap=tk.WORD, height=15, state=tk.DISABLED)\n        self.chat_display.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)\n        self.chat_entry = tk.Entry(frame)\n        self.chat_entry.pack(padx=5, pady=(0,5), fill=tk.X)\n        self.chat_entry.bind(\"<Return>\", self.send_message)\n",
    "summary": "The code defines a method to create and configure an interactive chat interface with disabled display text in Tkinter.",
    "key_concepts": [
      "_build_chat_frame",
      "parent widget",
      "tk.LabelFrame",
      "side option",
      "scrolledtext.ScrolledText",
      "wrap mode",
      "state property",
      "chat_display variable",
      "Entry widget",
      "send_message function",
      "padx padding",
      "pady spacing",
      "fill behavior",
      "expand flag"
    ],
    "tags": [
      "tkinter",
      "scrolledtext",
      "chat_frame",
      "entry_widget",
      "text_display",
      "message_sending",
      "frame_layout",
      "widget_packaging"
    ],
    "follow_up_questions": [],
    "sequence_index": 7,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__build_config_frame_6": {
    "id": "file_gui_python_function_LucidMemoryApp__build_config_frame_6",
    "raw": "    def _build_config_frame(self):\n        frame = tk.LabelFrame(self.root, text=\"Configuration\")\n        frame.pack(pady=5, padx=10, fill=\"x\")\n\n        tk.Label(frame, text=\"Backend URL:\").grid(row=0, column=0, sticky=\"w\", padx=5)\n        self.backend_entry = tk.Entry(frame, width=60)\n        self.backend_entry.grid(row=0, column=1, padx=5, pady=2, sticky=\"ew\")\n        self.backend_entry.insert(0, self.config.get('backend_url', ''))\n\n        tk.Label(frame, text=\"Model Name:\").grid(row=1, column=0, sticky=\"w\", padx=5)\n        self.model_entry = tk.Entry(frame, width=60)\n        self.model_entry.grid(row=1, column=1, padx=5, pady=2, sticky=\"ew\")\n        self.model_entry.insert(0, self.config.get('model_name', ''))\n\n        tk.Label(frame, text=\"Local Port:\").grid(row=2, column=0, sticky=\"w\", padx=5)\n        self.port_entry = tk.Entry(frame, width=10)\n        self.port_entry.grid(row=2, column=1, padx=(5,0), pady=2, sticky=\"w\")\n        self.port_entry.insert(0, str(self.config.get('local_proxy_port', 8000)))\n\n        tk.Button(frame, text=\"Save Config\", command=self.save_config).grid(row=3, column=1, sticky=\"e\", pady=5, padx=5)\n        frame.columnconfigure(1, weight=1)\n",
    "summary": "The code defines a method to create and display an interactive configuration window for setting backend URL, model name, local port in a Tkinter GUI application.",
    "key_concepts": [
      "Configuration Frame",
      "Tk LabelFrame",
      "Backend URL Entry",
      "Model Name Entry",
      "Local Port Entry",
      "Save Config Button",
      "Column Weighting"
    ],
    "tags": [
      "tkinter",
      "configuration_frame",
      "backend_url",
      "model_name",
      "local_port",
      "save_config",
      "entry_widget",
      "grid_layout",
      "label_frame",
      "root_window",
      "proxy_port",
      "widget_sticky",
      "command_binding",
      "default_value",
      "dynamic_entry_update",
      "custom_button_text",
      "padx_pady_padding",
      "weight_columnconfigure",
      "insert_default_placeholder"
    ],
    "follow_up_questions": [],
    "sequence_index": 5,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__check_digestor_readiness_4": {
    "id": "file_gui_python_function_LucidMemoryApp__check_digestor_readiness_4",
    "raw": "    def _check_digestor_readiness(self) -> bool:\n        \"\"\"Checks if Digestor can be initialized based on config.\"\"\"\n        if not self.config.get('backend_url') or not self.config.get('model_name'):\n            logging.error(\"Digestor readiness check: Missing backend_url or model_name.\")\n            return False\n        try:\n            Digestor() # This might raise errors if prompts.yaml is missing/invalid\n            logging.info(\"Digestor readiness check passed.\")\n            return True\n        except Exception as e: # Catch init errors (e.g., file not found)\n            logging.error(f\"Digestor readiness check failed: {e}\", exc_info=True)\n            return False\n",
    "summary": "The function checks if the Digestor component can be initialized by verifying necessary configuration parameters.",
    "key_concepts": [
      "Digestor initialization",
      "Readiness checking",
      "Backend URL missing",
      "Model name missing",
      "Logging error message",
      "Exception handling",
      "File not found exception",
      "Initialization errors",
      "Configuration retrieval",
      "Return value false",
      "Return value true",
      "Note: The text provided is a Python function, and the concepts listed are derived from its content."
    ],
    "tags": [
      "digestor initialization",
      "backend_url configuration",
      "model_name validation",
      "exception handling",
      "config retrieval",
      "error logging",
      "python function",
      "digestor readiness check"
    ],
    "follow_up_questions": [],
    "sequence_index": 3,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp___init___1": {
    "id": "file_gui_python_function_LucidMemoryApp___init___1",
    "raw": "    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Lucid Memory - GUI v0.2.5\")\n        self.config = self._load_config()\n        self.memory_graph = self._load_memory_graph()\n        self.digestor_ready = self._check_digestor_readiness()\n        self.server_process = None\n        self.processor_thread: Optional[threading.Thread] = None\n\n        self._build_ui()\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n        logging.info(\"GUI Initialized.\")\n        if not self.digestor_ready:\n             self.root.after(100, lambda: self._update_status_label(\"Status: Warning - Digestor config invalid.\"))\n",
    "summary": "The code initializes a GUI application for Lucid Memory v0.2.5 with configuration and memory graph loading capabilities, along with digestor readiness checks and UI building functionalities.",
    "key_concepts": [
      "GUI initialization",
      "Memory graph loading",
      "Config file loading",
      "Threading module",
      "Status label update",
      "Protocol handling",
      "Logging system",
      "Window closing event handler",
      "Digestor readiness check",
      "Server process management",
      "UI building",
      "Root window title setting",
      "Configuration validation"
    ],
    "tags": [
      "gui initialization",
      "digestor readiness",
      "lucid memory version 0.2.5",
      "tkinter threading",
      "memory graph loading",
      "status label update",
      "windows protocol event handling",
      "cfg file parsing",
      "python logging"
    ],
    "follow_up_questions": [],
    "sequence_index": 0,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__build_control_frame_10": {
    "id": "file_gui_python_function_LucidMemoryApp__build_control_frame_10",
    "raw": "    def _build_control_frame(self):\n        frame = tk.Frame(self.root)\n        frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)\n        tk.Button(frame, text=\"Load Context File\", command=self.load_context_file).pack(side=tk.LEFT, padx=5)\n        tk.Button(frame, text=\"Start Proxy Server\", command=self.start_server).pack(side=tk.LEFT, padx=5)\n        tk.Button(frame, text=\"Stop Proxy Server\", command=self.stop_server).pack(side=tk.LEFT, padx=5)\n        self.status_label = tk.Label(frame, text=\"Status: Initialized\", relief=tk.SUNKEN, anchor=\"w\")\n        self.status_label.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)\n",
    "summary": "The function creates a bottom toolbar with buttons to load context files and control proxy server operations in a Tkinter GUI.",
    "key_concepts": [
      "tk.Frame",
      "tk.Button",
      "load_context_file command",
      "start_server command",
      "stop_server command",
      "status_label",
      "Status: Initialized",
      "side=tk.BOTTOM",
      "fill=tk.X",
      "padx=10",
      "pady=5",
      "relief=tk.SUNKEN",
      "anchor=\"w\""
    ],
    "tags": [
      "tkinter",
      "tkinter_frame",
      "button_pack",
      "status_label",
      "proxy_server_control",
      "dynamic_layout",
      "command_binding",
      "widget_placement",
      "relief_sunken"
    ],
    "follow_up_questions": [],
    "sequence_index": 9,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__build_memory_frame_9": {
    "id": "file_gui_python_function_LucidMemoryApp__build_memory_frame_9",
    "raw": "    def _build_memory_frame(self, parent):\n        frame = tk.LabelFrame(parent, text=\"Memory Nodes\")\n        frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))\n        self.memory_list = scrolledtext.ScrolledText(frame, width=55, wrap=tk.WORD, state=tk.DISABLED)\n        self.memory_list.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)\n",
    "summary": "The code snippet creates a disabled ScrolledText widget within a LabelFrame for displaying memory nodes in a GUI.",
    "key_concepts": [
      "Memory Frame",
      "LabelFrame",
      "tk.LabelFrame",
      "parent widget",
      "scrolledtext.ScrolledText",
      "width setting",
      "wrap mode",
      "state property",
      "pack geometry",
      "side option",
      "fill behavior",
      "padx parameter",
      "pady spacing",
      "expand feature"
    ],
    "tags": [
      "tkinter",
      "memory_frame",
      "labelframe",
      "scrolledtext",
      "tkinter.widgets",
      "scrolledtext.scrolledtext",
      "wrap=tk.word",
      "state=tk.disabled",
      "parent=toplevel",
      "side=tk.right",
      "padx=(5",
      "0",
      "pady=5",
      "fill=tk.both",
      "expand=true"
    ],
    "follow_up_questions": [],
    "sequence_index": 8,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__update_status_label_11": {
    "id": "file_gui_python_function_LucidMemoryApp__update_status_label_11",
    "raw": "    def _update_status_label(self, text):\n        \"\"\"Safely updates status label via root.after().\"\"\"\n        self.root.after(0, lambda: self.status_label.config(text=text))\n",
    "summary": "Updates the application's status label with new text in a thread-safe manner.",
    "key_concepts": [
      "update status",
      "after method",
      "config property",
      "GUI element",
      "text configuration",
      "callback function",
      "root widget",
      "label component"
    ],
    "tags": [
      "root.after",
      "update_status_label",
      "config",
      "dynamic_text_update",
      "tkinter",
      "python_callback",
      "gui_update",
      "widget_reconfiguration"
    ],
    "follow_up_questions": [],
    "sequence_index": 10,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__handle_processing_completion_12": {
    "id": "file_gui_python_function_LucidMemoryApp__handle_processing_completion_12",
    "raw": "    def _handle_processing_completion(self, graph_changed: bool):\n        \"\"\"Callback when chunk processing finishes.\"\"\"\n        logging.info(f\"Processing completion callback. Graph changed: {graph_changed}\")\n        if graph_changed:\n            self.root.after(0, self.refresh_memory_display)\n        self.processor_thread = None # Clear thread tracker\n",
    "summary": "The function serves as a callback to refresh the memory display and clear processing threads upon completing chunk processing in an application.",
    "key_concepts": [
      "processing completion",
      "chunk processing",
      "callback function",
      "logging info",
      "root widget after method",
      "memory display refresh",
      "processor thread clear"
    ],
    "tags": [
      "processing_completion_callback",
      "threading",
      "memory_refresh",
      "root_widget",
      "logging_info",
      "processor_thread_cleanup"
    ],
    "follow_up_questions": [],
    "sequence_index": 11,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__append_chat_message_13": {
    "id": "file_gui_python_function_LucidMemoryApp__append_chat_message_13",
    "raw": "    def _append_chat_message(self, text):\n         \"\"\"Safely appends text to chat display via root.after().\"\"\"\n         def append():\n             self.chat_display.config(state=tk.NORMAL)\n             self.chat_display.insert(tk.END, text)\n             self.chat_display.config(state=tk.DISABLED)\n             self.chat_display.see(tk.END)\n         self.root.after(0, append)\n",
    "summary": "The function appends new chat messages to the display in a thread-safe manner.",
    "key_concepts": [
      "chat display",
      "root.after()",
      "tk.NORMAL",
      "tk.DISABLED",
      "tk.END",
      "text insertion",
      "state configuration",
      "GUI update",
      "Note: The above list includes concepts and entities that are directly related to the provided Python code snippet. Some items may seem like actions or methods, but they have been categorized as keywords/short phrases for this task based on their relevance in a technical context within software development (specifically GUIs)."
    ],
    "tags": [
      "root.after",
      "tkinter",
      "chat display configuration",
      "state management",
      "insert method",
      "dynamic updating",
      "gui programming",
      "event-driven programming",
      "text insertion",
      "secure appending"
    ],
    "follow_up_questions": [],
    "sequence_index": 12,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_save_config_14": {
    "id": "file_gui_python_function_LucidMemoryApp_save_config_14",
    "raw": "    def save_config(self):\n        \"\"\"Saves current configuration.\"\"\"\n        try:\n            new_port = int(self.port_entry.get())\n            new_config = {\n                \"backend_url\": self.backend_entry.get().strip(),\n                \"model_name\": self.model_entry.get().strip(),\n                \"local_proxy_port\": new_port\n            }\n            if not new_config['backend_url'] or not new_config['model_name']:\n                 raise ValueError(\"Backend URL/Model Name required.\")\n\n            # Keep try-except for file operations\n            os.makedirs(os.path.dirname(CONFIG_PATH), exist_ok=True)\n            with open(CONFIG_PATH, \"w\", encoding=\"utf-8\") as f:\n                json.dump(new_config, f, indent=2)\n\n            messagebox.showinfo(\"Saved\", \"Configuration updated.\")\n            self.config = new_config\n            self.digestor_ready = self._check_digestor_readiness()\n            status = \"Status: Config saved. Digestor \" + (\"ready.\" if self.digestor_ready else \"NOT ready.\")\n            self._update_status_label(status)\n        except ValueError as e:\n             messagebox.showerror(\"Input Error\", f\"{e}\") # More specific error\n        except Exception as e: # Keep broad except for file save\n             messagebox.showerror(\"Save Error\", f\"Failed to save configuration: {e}\")\n             logging.error(\"Save config error\", exc_info=True)\n",
    "summary": "The function `save_config` saves the current application settings into a JSON-formatted configuration file and updates related status indicators.",
    "key_concepts": [
      "Configuration saving",
      "Port entry retrieval",
      "Backend URL extraction",
      "Model name acquisition",
      "Local proxy port assignment",
      "File operations try-except block",
      "Directory creation with os.makedirs()",
      "JSON file writing",
      "Messagebox info display",
      "Status label updating",
      "Digestor readiness check",
      "Error handling and logging"
    ],
    "tags": [
      "config saving",
      "exception handling",
      "os.makedirs",
      "json serialization",
      "user interface feedback",
      "backend_url validation",
      "digestor readiness check",
      "file operations",
      "status update label"
    ],
    "follow_up_questions": [],
    "sequence_index": 13,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_send_message_15": {
    "id": "file_gui_python_function_LucidMemoryApp_send_message_15",
    "raw": "    def send_message(self, event=None):\n        \"\"\"Handles sending a message from the chat entry.\"\"\"\n        user_message = self.chat_entry.get().strip()\n        if not user_message: return\n        self.chat_entry.delete(0, tk.END)\n        self._append_chat_message(f\"User: {user_message}\\n\")\n\n        if not self.server_process or self.server_process.poll() is not None:\n             self._append_chat_message(\"Error: Proxy server not running.\\n\\n\")\n             return\n\n        proxy_url = f\"http://localhost:{self.config.get('local_proxy_port', 8000)}/chat\"\n        payload = { \"messages\": [{\"role\": \"user\", \"content\": user_message}], \"temperature\": 0.2 }\n        # Keep thread for network request to avoid blocking GUI\n        threading.Thread(target=self._send_request_thread, args=(proxy_url, payload), daemon=True).start()\n",
    "summary": "The `send_message` function sends a user's message from the chat entry through an active proxy server and updates both local UI with error handling.",
    "key_concepts": [
      "send_message function",
      "chat entry message retrieval",
      "user input validation",
      "server process check",
      "proxy URL construction",
      "network request threading",
      "GUI non-blocking operation",
      "payload creation for API call",
      "role assignment in messages",
      "temperature parameter setting"
    ],
    "tags": [
      "threading",
      "chat_entry",
      "server_process",
      "proxy_server",
      "temperature_control",
      "gui_interaction",
      "message_payload",
      "http_proxy",
      "user_input_handling",
      "network_request_threading"
    ],
    "follow_up_questions": [],
    "sequence_index": 14,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp__send_request_thread_16": {
    "id": "file_gui_python_function_LucidMemoryApp__send_request_thread_16",
    "raw": "    def _send_request_thread(self, url, payload):\n        \"\"\"Sends HTTP request in background. Updates chat UI.\"\"\"\n        try: # Keep try-except for network/request errors\n            response = requests.post(url, json=payload, timeout=60)\n            response.raise_for_status() # Check for HTTP errors 4xx/5xx\n            data = response.json()\n            reply = \"Error: Could not parse LLM response.\"\n            # Simplify response checking slightly\n            choices = data.get(\"choices\")\n            if isinstance(choices, list) and choices:\n                 msg = choices[0].get(\"message\")\n                 reply = msg.get(\"content\", reply) if isinstance(msg, dict) else reply\n            self._append_chat_message(f\"Assistant: {reply}\\n\\n\")\n        except requests.exceptions.Timeout:\n            self._append_chat_message(\"Error: Chat request timed out.\\n\\n\")\n        except requests.exceptions.RequestException as e: # Catch all request-related errors\n            logging.warning(f\"Proxy comm error: {e}\", exc_info=False)\n            self._append_chat_message(f\"Error communicating with proxy: {e}\\n\\n\")\n        except Exception as e: # Catch potential JSON errors or others\n            logging.error(\"Process chat response error\", exc_info=True)\n            self._append_chat_message(f\"Error processing response: {e}\\n\\n\")\n",
    "summary": "The function sends an HTTP POST request in the background and updates a user interface with responses from it.",
    "key_concepts": [
      "HTTP request thread",
      "Chat UI update",
      "Network/request errors handling",
      "Post method usage",
      "Response checking 4xx/5xx status codes",
      "JSON parsing error message",
      "List data structure manipulation",
      "Timeout exception catching",
      "Request-related exceptions logging",
      "Proxy communication failure",
      "Process response error handling"
    ],
    "tags": [
      "http request",
      "background thread",
      "http post",
      "json parsing",
      "exception handling",
      "timeout exceptions",
      "requests library",
      "network errors",
      "proxy communication",
      "chat ui update",
      "logging",
      "error messages"
    ],
    "follow_up_questions": [],
    "sequence_index": 15,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_start_server_19": {
    "id": "file_gui_python_function_LucidMemoryApp_start_server_19",
    "raw": "    def start_server(self):\n        \"\"\"Starts the Uvicorn proxy server subprocess.\"\"\"\n        if self.server_process and self.server_process.poll() is None:\n            messagebox.showinfo(\"Server\", \"Already running.\"); return\n        py_exe = os.sys.executable; mod_path = \"lucid_memory.proxy_server:app\"\n        try: # Keep try-except for subprocess/port errors\n            port_str = self.port_entry.get(); int(port_str) # Validate\n            cmd = [py_exe, \"-m\", \"uvicorn\", mod_path, \"--host\", \"0.0.0.0\", \"--port\", port_str, \"--reload\", \"--log-level\", \"warning\"]\n            logging.info(f\"Starting server: {' '.join(cmd)}\"); startupinfo = None\n            if os.name == 'nt': startupinfo = subprocess.STARTUPINFO(); startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW; startupinfo.wShowWindow = subprocess.SW_HIDE\n            # Use text=True for easier stdout/stderr handling\n            self.server_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace', startupinfo=startupinfo)\n            self._update_status_label(f\"Status: Proxy server starting on port {port_str}...\")\n            self.root.after(2000, self.check_server_status) # Check later\n        except ValueError: messagebox.showerror(\"Error\", \"Invalid port number.\")\n        except Exception as e: logging.error(f\"Server launch fail: {e}\", exc_info=True); messagebox.showerror(\"Server Error\", f\"Failed: {e}\"); self._update_status_label(\"Status: Failed start\")\n",
    "summary": "The function starts a Uvicorn proxy server subprocess on the specified port.",
    "key_concepts": [
      "Uvicorn proxy server",
      "server_process subprocess",
      "messagebox info error",
      "port_entry validation int port_str cmd startupinfo os.name nt Windows hidden stdout stderr text utf-8 errors replace status label update check_server_status ValueError Exception launch fail logging info log_level warning reload host 0.0.0.0 restart"
    ],
    "tags": [
      "subprocess",
      "uvicorn",
      "server_process",
      "port_entry",
      "os.name",
      "startupinfo",
      "logging",
      "text=true",
      "subprocess.popen",
      "valueerror",
      "messagebox",
      "exc_info",
      "statuslabel",
      "stdout",
      "stderr",
      "encoding",
      "errors",
      "popen",
      "startupinfo",
      "sw_hide",
      "start_server",
      "app",
      "lucid_memory.proxy_server"
    ],
    "follow_up_questions": [],
    "sequence_index": 18,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_load_context_file_17": {
    "id": "file_gui_python_function_LucidMemoryApp_load_context_file_17",
    "raw": "    def load_context_file(self):\n        \"\"\"Opens file dialog, chunks file, and starts Processor in background thread.\"\"\"\n        if not self.digestor_ready:\n            messagebox.showerror(\"Error\", \"Digestor not ready. Check config.\"); return\n        if self.processor_thread and self.processor_thread.is_alive():\n             messagebox.showwarning(\"Busy\", \"Already processing file.\"); return\n\n        filename = filedialog.askopenfilename(\n            title=\"Select Context File\",\n            filetypes=((\"Python\",\"*.py\"),(\"Markdown\",\"*.md\"),(\"Text\",\"*.txt\"),(\"All\",\"*.*\"))\n        )\n        if not filename: return\n\n        try: # Keep try-except for file reading/chunking\n            with open(filename, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n                 raw_text = f.read()\n\n            logging.info(f\"Starting chunking for {filename}\")\n            self._update_status_label(f\"Status: Chunking {os.path.basename(filename)}...\")\n            self.root.update_idletasks()\n            chunks = chunk_file(filename, raw_text) # External call, might fail\n            if not chunks:\n                 messagebox.showwarning(\"Chunking\", \"File yielded no chunks.\"); self._update_status_label(\"Status: File not chunked.\"); return\n\n            logging.info(f\"Chunking complete ({len(chunks)} chunks). Initializing processor...\")\n            self._update_status_label(f\"Status: Chunked ({len(chunks)}). Starting digestion...\")\n            self.root.update_idletasks()\n\n            # Keep try-except for critical Digestor init\n            try: current_digestor = Digestor()\n            except Exception as e: logging.error(f\"Failed Digestor init: {e}\", exc_info=True); messagebox.showerror(\"Error\", f\"Digestor init failed: {e}\"); self._update_status_label(\"Status: Error - Failed Digestor init.\"); return\n\n            processor = ChunkProcessor( digestor=current_digestor, memory_graph=self.memory_graph, status_callback=self._update_status_label, completion_callback=self._handle_processing_completion )\n            self.processor_thread = threading.Thread( target=processor.process_chunks, args=(chunks, os.path.basename(filename)), daemon=True )\n            self.processor_thread.start()\n\n        except Exception as e: # Catch file read or chunk_file errors\n            logging.error(f\"File Read/Chunk Error: {e}\", exc_info=True)\n            messagebox.showerror(\"File Load Error\", f\"Read/chunk failed: {e}\")\n            self._update_status_label(\"Status: Error reading/chunking file\")\n",
    "summary": "The function `load_context_file` opens a dialog to select and process text files in chunks using an external processor, updating the status along the way.",
    "key_concepts": [
      "File dialog",
      "Processor thread",
      "Digestor ready check",
      "Messagebox error/warning",
      "Select context file",
      "Open file with encoding",
      "Chunk_file function",
      "Status label update",
      "Threading for processing",
      "External call failure handling",
      "Critical exception catching",
      "Memory graph usage",
      "Completion callback",
      "File read errors"
    ],
    "tags": [
      "file_dialog",
      "processor_thread",
      "digestor_ready",
      "chunk_file",
      "exception_handling",
      "threading",
      "logging",
      "status_update",
      "external_call",
      "try-except block",
      "messagebox",
      "encoding_utf-8",
      "memory_graph",
      "completion_callback",
      "python_filetypes",
      "markdown_filetypes",
      "text_filetypes",
      "file_reading_error",
      "digestion_process"
    ],
    "follow_up_questions": [],
    "sequence_index": 16,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_check_server_status_20": {
    "id": "file_gui_python_function_LucidMemoryApp_check_server_status_20",
    "raw": "    def check_server_status(self):\n        \"\"\"Checks if the server process is running or terminated.\"\"\"\n        if not self.server_process: return\n        rc = self.server_process.poll()\n        if rc is not None: # Server terminated\n            # Simplified error reading (might miss output if read too late)\n            stderr = self.server_process.stderr.read() if self.server_process.stderr else \"(No stderr)\"\n            stdout = self.server_process.stdout.read() if self.server_process.stdout else \"(No stdout)\"\n            logging.error(f\"Server terminated (code {rc}).\\nStderr: {stderr}\\nStdout: {stdout}\")\n            messagebox.showerror(\"Server Error\", f\"Server terminated (code {rc}). Check logs.\")\n            self._update_status_label(\"Status: Server terminated unexpectedly\")\n            self.server_process = None\n        else: # Server still running\n            self._update_status_label(f\"Status: Proxy server running on port {self.port_entry.get()}\")\n",
    "summary": "The function checks the status of a proxy server process, indicating whether it is active or has terminated.",
    "key_concepts": [
      "check_server_status function",
      "server process status",
      "poll method",
      "stderr attribute",
      "stdout attribute",
      "logging.error message",
      "messagebox.showerror dialog",
      "_update_status_label method",
      "proxy server running",
      "port_entry widget"
    ],
    "tags": [
      "server process",
      "polling",
      "stderr",
      "stdout",
      "logging.error",
      "messagebox.showerror",
      "status label",
      "proxy server",
      "terminate unexpectedly"
    ],
    "follow_up_questions": [],
    "sequence_index": 19,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_refresh_memory_display_18": {
    "id": "file_gui_python_function_LucidMemoryApp_refresh_memory_display_18",
    "raw": "    def refresh_memory_display(self):\n        \"\"\"Clears and re-populates the memory list, now showing linking info.\"\"\"\n        try:\n            self.memory_list.config(state=tk.NORMAL)\n            self.memory_list.delete(1.0, tk.END)\n            if not self.memory_graph.nodes:\n                self.memory_list.insert(tk.END, \"(Memory graph is empty)\")\n            else:\n                # Sort nodes perhaps by sequence index if available, then ID\n                sorted_nodes = sorted(self.memory_graph.nodes.items(), key=lambda item: (getattr(item[1], 'sequence_index', float('inf')), item[0]))\n\n                for node_id, node in sorted_nodes:\n                    # --- Build display text ---\n                    display_text = f\"ID: {node.id}\\n\"\n                    # Add sequence and parent if available\n                    seq_idx = getattr(node, 'sequence_index', None)\n                    parent_id = getattr(node, 'parent_identifier', None)\n                    if seq_idx is not None: display_text += f\"Seq: {seq_idx}\\n\"\n                    if parent_id: display_text += f\"Parent: {parent_id}\\n\"\n\n                    # Add metadata identifier if available (redundant if parent_id is clear)\n                    # metadata = getattr(node, 'source_chunk_metadata', None)\n                    # if metadata and metadata.get('identifier'): display_text += f\"Source ID: {metadata['identifier']}\\n\"\n\n                    display_text += f\"Summary: {node.summary}\\n\"\n                    display_text += f\"Tags: {', '.join(node.tags) if node.tags else '(None)'}\\n\"\n                    # Determine field name dynamically (key_concepts or logical_steps)\n                    concepts_or_steps = getattr(node, 'key_concepts', getattr(node, 'logical_steps', []))\n                    concepts_label = \"Concepts\" if hasattr(node, 'key_concepts') else \"Logical Steps\"\n                    display_text += f\"{concepts_label} ({len(concepts_or_steps)}):\\n\"\n                    display_text += \"\".join([f\"  - {item}\\n\" for item in concepts_or_steps]) if concepts_or_steps else \"  (None extracted)\\n\"\n                    display_text += f\"Follow-up ({len(node.follow_up_questions)}):\\n\"\n                    display_text += \"\".join([f\"  ? {q}\\n\" for q in node.follow_up_questions]) if node.follow_up_questions else \"  (None)\\n\"\n                    display_text += \"-\" * 20 + \"\\n\\n\"\n                    self.memory_list.insert(tk.END, display_text)\n            self.memory_list.see(tk.END)\n        except Exception as e:\n            logging.error(f\"Refresh display error: {e}\", exc_info=True)\n            try:\n                self.memory_list.insert(tk.END, f\"\\n--- ERROR REFRESHING DISPLAY ---\\n{e}\\n\")\n            except Exception: pass\n        finally:\n            self.memory_list.config(state=tk.DISABLED)\n",
    "summary": "The function refreshes and updates a memory display with sorted node information including ID, sequence index, parent identifier, summary, tags, key concepts or logical steps, follow-up questions, while handling errors gracefully.",
    "key_concepts": [
      "Memory list refresh",
      "Tkinter configuration state",
      "Node sorting by index and ID",
      "Display text construction",
      "Sequence indexing",
      "Parent identifier retrieval",
      "Metadata identification",
      "Summary display",
      "Tag listing",
      "Key concepts extraction",
      "Logical steps determination",
      "Follow-up questions enumeration",
      "Error logging"
    ],
    "tags": [
      "memory_display_refresh",
      "tcltk",
      "memory_graph",
      "nodes",
      "sorting",
      "display_text",
      "node_attributes",
      "parent_identifier",
      "key_concepts",
      "logical_steps",
      "follow_up_questions",
      "error_handling",
      "lifecycle_state",
      "tkinter_gui",
      "caching",
      "redundant_metadata",
      "dynamic_field_name",
      "sequence_index",
      "getattr",
      "setting",
      "state_change",
      "toplevel_window"
    ],
    "follow_up_questions": [],
    "sequence_index": 17,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_stop_server_21": {
    "id": "file_gui_python_function_LucidMemoryApp_stop_server_21",
    "raw": "    def stop_server(self):\n        \"\"\"Stops the running Uvicorn server process.\"\"\"\n        if self.server_process and self.server_process.poll() is None:\n            logging.info(\"Stopping server...\");\n            try: # Keep try-except for process termination\n                self.server_process.terminate()\n                try: self.server_process.wait(timeout=3) # Shorter wait\n                except subprocess.TimeoutExpired: logging.warning(\"Killing server.\"); self.server_process.kill(); self.server_process.wait()\n                logging.info(\"Server stopped.\"); messagebox.showinfo(\"Server\", \"Server stopped.\")\n                self._update_status_label(\"Status: Stopped\")\n            except Exception as e: logging.error(f\"Stop server error: {e}\", exc_info=True); messagebox.showerror(\"Server Error\", f\"Stop error: {e}\"); self._update_status_label(\"Status: Error stopping\")\n            finally: self.server_process = None\n        else:\n            logging.info(\"Stop called, server not running.\")\n            self._update_status_label(\"Status: Idle (Server not running)\") if \"running\" in self.status_label.cget(\"text\") else None\n",
    "summary": "The function stops a Uvicorn server process and updates the status label accordingly.",
    "key_concepts": [
      "Uvicorn process",
      "Server stop function",
      "Process termination",
      "Timeout handling",
      "Logging info/warning/error",
      "Status label update",
      "Exception catching",
      "Messagebox info/error",
      "Running server check",
      "Idle status label",
      "Subprocess management"
    ],
    "tags": [
      "process termination",
      "subprocess timeout",
      "exception handling",
      "uvicorn server management",
      "logging",
      "status label update",
      "process monitoring",
      "error reporting"
    ],
    "follow_up_questions": [],
    "sequence_index": 20,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_main_23": {
    "id": "file_gui_python_function_main_23",
    "raw": "def main():\n    root = tk.Tk()\n    root.minsize(700, 500)\n    app = LucidMemoryApp(root)\n    root.mainloop()\n",
    "summary": "The code initializes and runs a Tkinter-based GUI application called LucidMemoryApp.",
    "key_concepts": [
      "tkinter",
      "Tk instance",
      "minsize method",
      "LucidMemoryApp class",
      "mainloop event loop"
    ],
    "tags": [
      "tkinter",
      "python",
      "gui application",
      "lucid memory app",
      "tkinter widget",
      "event loop",
      "graphical user interface",
      "mainloop",
      "minsize function"
    ],
    "follow_up_questions": [],
    "sequence_index": 22,
    "parent_identifier": "gui",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  },
  "file_gui_python_function_LucidMemoryApp_on_closing_22": {
    "id": "file_gui_python_function_LucidMemoryApp_on_closing_22",
    "raw": "    def on_closing(self):\n        \"\"\"Handles window close event.\"\"\"\n        if self.server_process and self.server_process.poll() is None:\n            if messagebox.askokcancel(\"Quit\", \"Server running. Stop and exit?\"):\n                self.stop_server()\n                self.root.destroy()\n        else:\n            self.root.destroy()\n",
    "summary": "The function handles the closing of a window, prompting for confirmation to stop an associated server before exiting.",
    "key_concepts": [
      "window close event",
      "server process poll",
      "messagebox askokcancel",
      "stop server",
      "root destroy"
    ],
    "tags": [
      "window closing",
      "event handling",
      "server process",
      "poll method",
      "tkinter",
      "stop function",
      "root window destruction"
    ],
    "follow_up_questions": [],
    "sequence_index": 21,
    "parent_identifier": "LucidMemoryApp",
    "source": null,
    "inputs": [],
    "outputs": [],
    "internal_vars": []
  }
}